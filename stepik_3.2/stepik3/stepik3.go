// package main

// import (
// 	"bufio"
// 	"fmt"
// 	"os"
// 	"strconv"
// 	"strings"
// )

// func main() {

// 	text, _ := bufio.NewReader(os.Stdin).ReadString('\n')
// 	text = strings.Trim(text, "\n")

// 	text = strings.Replace(text, " ", "", -1)
// 	text = strings.Replace(text, ",", ".", -1)
// 	items := strings.Split(text, ";")
// 	if len(items) != 2 {
// 		panic("invalid format, must be two values!")
// 	}

// 	num1, err := strconv.ParseFloat(items[0], 64) // из стринга в флоат64
// 	if err != nil {
// 		panic(err)
// 	}
// 	num2, err := strconv.ParseFloat(items[1], 64)
// 	if err != nil {
// 		panic(err)
// 	}

// 	fmt.Printf("%.4f\n", num1/num2)

// }

package main

import "fmt"

func recieveFunc(f func(a, b int) int) int {
	var a1, a2 int
	a1 = 100
	a2 = 150
	return f(a1, a2)
}

func add(a2, b2 int) int {
	return a2 + b2
}

func main() {
	fmt.Println(recieveFunc(add))

}

/*
Для решения данной задачи вам понадобится пакет strconv, возможно использовать
пакеты strings или encoding/csv, или даже bufio - вы не ограничены в выборе
способа решения задачи. В решениях мы поделимся своими способами решения
этой задачи, предлагаем вам сделать то же самое.

В привычных нам редакторах электронных таблиц присутствует удобное представление
числа с разделителем разрядов в виде пробела, кроме того в России целая часть от
дробной отделяется запятой. Набор таких чисел был экспортирован в формат CSV, где
в качестве разделителя используется символ ";".

На стандартный ввод вы получаете 2 таких вещественных числа, в качестве результата
требуется вывести частное от деления первого числа на второе с точностью до четырех
знаков после "запятой" (на самом деле после точки, результат не требуется приводить
к исходному формату).

P.S. небольшое отступление, связанное с чтением из стандартного ввода. Кто-то захочет
использовать для этого пакет bufio.Reader. Это вполне допустимый вариант, но если вы
резонно обрабатываете ошибку метода ReadString('\n'), то получаете ошибку EOF, а
точнее (io.EOF - End Of File). На самом деле это не ошибка, а состояние, означающее,
что файл (а os.Stdin является файлом) прочитан до конца. Чтобы ошибка была обработана
правильно, вы можете поступить так:
if err != nil && err != io.EOF {
	...
}

Sample Input:
1 149,6088607594936;1 179,0666666666666

Sample Output:
0.9750
*/
